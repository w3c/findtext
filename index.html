<!DOCTYPE html>
<html>
  <head>
    <title>FindText API</title>
    <meta charset='utf-8'>

    <link rel="canonical" href="http://www.w3.org/TR/findtext/">
    <!--
    <script src="https://notes.webplatform.org/annotator.js" async defer></script>
    -->

    <script src='https://www.w3.org/Tools/respec/respec-w3c-common' class='remove'></script>
    <script class='remove'>
      var respecConfig = {
        shortName:  "findtext-api",
        specStatus: "ED",
        edDraftURI: "http://w3c.github.io/findtext/",
        editors: [
              {   
                name:       "Doug Schepers",
                url:        "http://schepers.cc/",
                w3cid:      "38635",
                company:    "W3C",
                companyURL: "http://w3.org/" 
              }
        ],
        wg:           "Web Annotation Working Group",
        wgURI:        "http://www.w3.org/annotation/",
        wgPublicList: "public-annotation",
        wgPatentURI:  "http://www.w3.org/2004/01/pp-impl/73180/status",
        tocIntroductory: true
      };
    </script>
    <style type="text/css">
      .example {
        margin-left: 2em;
        font-style: italic;
      }

      .highlight {
        background-color: yellow; 
      }

      dt {
        padding-top: 0.5em;
      }

        dd > p {
          margin-top: 0;
          padding-top: 0;
        }
    </style>
  </head>
  <body>
    <section id='abstract' class="informative">
      <p>
        This specification describes an API for finding ranges of text in a document or part of a document, using a variety of selection criteria.
      </p>

      <p class="note">
        This specification is a strawman, intended to collect feedback. It is not stable, and radical ideas for improvement are welcome.
      </p>
    </section>

    <section id='sotd'>
      <p>
        The API described in this document is still experimental.
      </p>

      <p class="note">
        Feedback on this specification can be made via annotations. All annotations are archived on the <a rel="reply-to" href="mailto:public-annotation@w3.org">public-annotation@w3.org</a> mailing list (<a href="http://lists.w3.org/Archives/Public/public-annotation/">archives</a>), and on the searchable <a href="https://notes.webplatform.org/stream">WebPlatform Notes stream</a>; see more details on <a href="https://notes.webplatform.org/">Notes.WebPlatform.org</a>. <b>Note:</b> To create annotations, you must have a <a href="https://accounts.webplatform.org/">WebPlatform.org account</a>; do not use your W3C credentials.
      </p>

      <p>This document is published jointly by the <a href="http://www.w3.org/2008/webapps/">Web Applications Working Group</a> and the <a href="http://www.w3.org/annotation/">Web Annotation Woring Group</a>.</p>
    </section>
    
    <section class="informative">
      <h2>Introduction</h2>
      <p>
        Finding a text selection is a basic operation of a Web browser, but the functionality is not exposed to Web developers. The FindText API provides a way for developers to find text selections, with several options to refine more targeted and flexible searches, including fuzzy matching, in a way that works well with a variety of human languages.  
      </p>
      <p>
        There are many different use cases for a custom mechanism for finding and navigating to a particular range of text in a Web document, such as [[!HTML5]] or [[!SVG]]. A developer may wish to design a webapp in which only the text in the active editing subtreee, and not the controls or other application text, is returned as a result of a search, overriding the native find-text functionality. A user may wish to highlight a particular passage, and link to it, even if that selection doesn't have a <code>id</code> attribute to serve as a fragment identifier. A designer may wish to find and style a range of text without changing the markup. A developer may wish to provide a particular text-matching algorithm for searching their specific type of content, to return more meaningful results (such as fuzzy matching or term substitution). A CMS developer may wish to allow advanced review and commenting on text selections for a collaborative document. All of these use cases share the a fundamental requirement for a API to find text.  
      </p>
      <p>
        There are many challenges to finding text in a modern Web document. 

        The content may have changed; the change could be a document restructuring, the addition of content before the target selection, or even a change to the target string itself. In dynamic documents, such as real-time collaborative editing webapps, the content may change during the same session as the selection; in linking or annotation scenarios, the state is lost between sessions, so other search and anchoring strategies must be used.

        Highly repetitive content, such as poetry or lyrics, may duplicate the same passage several times, making it difficult to indicate a specific instance of that passage.

        Large documents may have many possible matches, such that search-ahead mechanism may be computationally expensive. 

        In dynamic lazy-loaded (or “infinite-scroll”) content, the text being searched for may not have been loaded into the DOM yet.
      </p>
      <p>
        There are also quirks in some native browser find-text mechanisms that could be improved through this API. For example, most current browsers do not let the user search for text across element boundaries (such as a string broken across different paragraphs or list items), which may be unintuitive and inconvenient to the end-user. Not all browsers allow the user to specify case-sensitive or whole-word search parameters, and not all browsers indicate the number of returned results. Browsers do not typically match language patterns that may be found in non-Latin character sets, including collapsed Unicode character sequences, optional diacritical marks, or similar features, such as matching <code>o</code> to <code>ó</code>, <code>ö</code>, <code>ø</code>, and <code>oe</code>.
      </p>
      <p>
        Sometimes, a selection of a document may contain more than text, or no text at all. Such selections include a picture and its caption, the picture alone, a specific area of a picture, a point on a rendered map, or a range of time within timed media such as audio or video. Some of these examples can be fully expressed as a DOM range; others need supplementary characteristics, which may be application-specific, in order to be addressable.
      </p>
      <p>
        The FindText API is intended to be flexible and performant. To ensure interoperability, this specification describes a default find-text algorithm, but this can be overriden by the developer. For flexibility in searches, this specification defines several parameterized selector methods, which can be applied in different ordered sequences to best match particular kinds of content, via method chaining, which will allow the developer to provide refined matching algorithms to customize the results.

        For performance reasons, the FindText API can be evoked iteratively, to find the next match in the document, rather than attempting to search the entire document for all matches.
      </p>
      <p>
        The result of a FindText search is an object that contains the found range, and any additional addressing characteristics. By running a search multiple times and comparing the results against the search criteria, a script can determine the best match for that set of search criteria. A script can also add or subtract selectors based on the results to refine a search.
      </p>


      <p class="note">
        This specification defines the behavior for documents using a Unicode character encoding, such as UTF-8. Behavior for documents using legacy character encoding, such as <code>windows-1252</code>, may be anomolous.
      </p>
      
      <p class="issue">
        Should the return object also contain the CSS and/or XPath selector that is the closest match for the selection? Can you get that easily from another Web Platform feature?
      </p>
      <p class="note">
        This specification defines what is returned, but not the specific algorithms used to find that result, or the speed or optimizations taken. Such optimizations are implementation-specific.
      </p>

      <p class="note">
        For character counts in ranges, what exactly would be counted as a character? Unicode code points? Graphemes?
      </p>

      <p class="issue">
        Address the issue of multiple concurrent FindText objects executing, especially when they are from different code bases (e.g. a custom find-in-page dialog running at the same time as an annotation client library). Presumably, the implementation could optimize by having them use the same <a>search content</a>?
      </p>

      <p class="issue">
        What's the expectation for updating the <a>search content</a> to reflect the state of the dynamic DOM, while a FindText object is executing?
      </p>

      <p class="note">
        This specification shares some conceptual similarities to the Selection API. Both deal with collections of ranges; while the Selection API deals with user actions in a live DOM, the FindText API deals with programmatic selection of ranges based on text criteria. The main interrelation between them is that one user might make a selection in a document, which can be serialized as text in such a way that another user could recreate that selection on their own instance of the document (e.g. you can store and share selections across devices). The use cases are otherwise very different. 
      </p>
   
    </section> 


    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        The following concepts and interfaces are defined in [[!HTML5]]:
      </p>
      <ul>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/webappapis.html#queue-a-task">queue a
          task</a></dfn>
        </li>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/webappapis.html#fire-a-simple-event">fire
          a simple event</a></dfn>
        </li>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/webappapis.html#event-handlers">event
          handler</a></dfn>
        </li>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/webappapis.html#event-handler-event-type">event
          handler event type</a></dfn>
        </li>
        <li>
          <code><dfn><a href=
          'http://www.w3.org/TR/html5/browsers.html#window'>Window</a></dfn></code>
        </li>
        <li>
          <code><dfn><a href=
          'http://www.w3.org/TR/html5/dom.html#document'>Document</a></dfn></code>
        </li>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/browsers.html#browsing-context">browsing
          context</a></dfn>
        </li>
        <li>
          <dfn><a href=
          "http://www.w3.org/TR/html5/browsers.html#top-level-browsing-context">
          top-level browsing context</a></dfn>
        </li>
        <li>browsing context's <dfn><a href=
        'http://www.w3.org/TR/html5/browsers.html#active-document'>active
        document</a></dfn>
        </li>
        <li>
          <dfn><a href=
          'http://www.w3.org/TR/html5/browsers.html#navigate'>navigated</a></dfn>
          browsing context
        </li>
        <li>
          <dfn><a href=
          'http://www.w3.org/TR/html5/browsers.html#active-sandboxing-flag-set'>
          active sandboxing flag set</a></dfn>
        </li>
        <li>
          <dfn><a href=
          'http://www.w3.org/TR/html5/webappapis.html#responsible-document'>responsible
          document</a></dfn>
        </li>
        <li>
          <dfn><a href=
          'http://www.w3.org/TR/html5/browsers.html#list-of-the-descendant-browsing-contexts'>
          list of the descendant browsing contexts</a></dfn>
        </li>
      </ul>
      <p>
        <a href=
        'http://people.mozilla.org/~jorendorff/es6-draft.html#sec-promise-objects'>
        <dfn>Promise</dfn> objects</a> are defined in [[!ECMASCRIPT]].
      </p>
      <p>
        The following concepts and interfaces are defined in [[!DOM4]]:
      </p>
      <ul>
        <li>
          <dfn><a href="http://www.w3.org/TR/dom/#concept-range">Range object</a></dfn>
        </li>
        <li>
          <dfn><a href="http://www.w3.org/TR/dom/#dom-node-textcontent">textContent attribute</a></dfn>
        </li>
      </ul>
    </section>


    <section id="conformance">
      <p>
        The following conformance classes are defined by this specification: 
      </p>
      <dl>
        <dt><dfn id="dfn-conforming-implementation">conforming implementation</dfn></dt>
        <dd>
          <p>
            A <dfn id="dfn-user-agent">user agent</dfn> is considered to be a <a class="dfnref" href="#dfn-conforming-implementation">conforming implementation</a> if it satisfies all of the MUST-, REQUIRED- and SHALL-level criteria in this specification that apply to implementations. 
          </p>
        </dd>
      </dl>
      <p>
        User agents that use ECMAScript to implement the APIs defined in this
        specification must implement them in a manner consistent with the ECMAScript
        Bindings defined in the Web IDL specification [[!WEBIDL]] as this
        specification uses that specification and terminology.
      </p>
    </section>

    <section id="terms">
      <h2>
        Terminology
      </h2>
      <dl>
        <dt>
          <dfn id="edit_distance">edit distance</dfn>
        </dt>
        <dd>
          <p>
            The edit distance tolerance is the number of operations between the supplied target text attribute string and the candidate text content of the document. The edit distance is measured as the number of operations, of the set <i>delete</i>, <i>insert</i>, <i>replace</i>, and <i>transpose</i>, required to transform one string into another. 
          </p>

          <p class="issue">
            Decide which algorithm to use to calculate this value: Levenshtein; Damerau–Levenshtein; Hamming; Jaro–Winkler (unlikely); or some other edit distance algorithm.
          </p>

          <p class="issue">
            Should this edit distance apply to the values of the <code>prefix</code> and <code>suffix</code> attributes as well?
          </p>

          <p class="issue">
            Expose edit-distance calculator as low-level API?
          </p>

          <p class="issue">
            What about "close key" calculations (keyboard-specific)
          </p>            
        </dd>

        <dt>
          <dfn id="search_tree">search tree</dfn>
        </dt>
        <dd>
          The <a>search tree</a> is the subset of the document that the <a>FindText</a> object is scoped to search in.
        </dd>

        <dt>
          <dfn id="search_content">search content</dfn>
        </dt>
        <dd>
          The <a>search content</a> is the normalized element text content from the <a>search tree</a>.
        </dd>

        <dt>
          <dfn id="search_cursor">search cursor</dfn>
        </dt>
        <dd>
          The <a>search cursor</a> is the character position of the <a>search operation</a> in the <a>search content</a>.

          <p class="issue">
            Should <a>search cursor</a> be exposed as a property of the <a>FindText</a> interface? That might allow more fine-grained control of the interface, and provide a way to detect the current search progress state (which might mean also exposing the total character length of the <a>search content</a>).
          </p>

          <p class="issue">
            Would this be clearer if it were named <a>search index</a>?
          </p>
        </dd>

        <dt>
          <dfn id="search_operation">search operation</dfn>
        </dt>
        <dd>
          The <a>search operation</a> is the current execution of the <a class="idlType" href="#widl-FindText-search-Promise-ResultMatch--boolean-forward"><code>search</code></a> method of the <a>FindText</a> interface.
        </dd>

        <dt>
          <dfn id="whitespace_character">whitespace character</dfn>
        </dt>
        <dd>
          <p>
            A whitespace character is any character with the Unicode character property "WSpace=Y", including the following codepoints: U+0009 (character tabulation); U+000A (line feed); U+000B (line tabulation); U+000C (form feed); U+000D (carriage return); U+0020 (space); U+0085 (next line); U+00A0 (no-break space); U+1680 (ogham space mark); U+2000 (en quad); U+2001 (em quad); U+2002 (en space); U+2003 (em space); U+2004 (three-per-em space); U+2005 (four-per-em space); U+2006 (six-per-em space); U+2007 (figure space); U+2008 (punctuation space); U+2009 (thin space); U+200A (hair space); U+2028 (line separator); U+2029 (paragraph separator); U+202F (narrow no-break space); U+205F (medium mathematical space); U+3000 (ideographic space).. 
          </p>
        </dd>
      </dl>
    </section>

    <section id="findtextapi">
      <h2 id="api">
        The FindText API
      </h2>
      <p>
        The FindText API enables a client-side script to incrementally search the DOM of the current document for matching strings, elements, or other DOM structures, based on criteria set with dedicated methods.
      </p>
<!-- 
      <section>
        <h2>The ResultMatch object</h2>
      </section>

      <section>
        <h2>The FindTextArgs object</h2>

      </section>
 -->
      <section>
        <h2 id="FindText">
          The FindText Interface
        </h2>
        <p>
          This interface represents an object which allows for the discovery of arbitrary selections of a document based on criteria set out in its attributes. The constructor takes an optional property object to set the selecotr attributes. The results of the FindText object's search are obtained through iterative execution of the <code>search()</code> method.
        </p>

        <dl title='[Constructor(optional FindTextArgs args)] interface FindText : EventTarget' class='idl' data-merge="FindTextState ResultMatch ResultMatchAll FindTextArgs caseFoldingType UnicodeEquivalenceType">
          <dt>
            attribute DOMString text
          </dt>
          <dd>
            <p>
              A text string to be searched for. <b>Note:</b> This string is equivalent to the <code>textContent</code> of a DOM node.
            </p>

            <p>The default value of the <a>text</a> attribute MUST be the empty string.</p>
          </dd>

          <dt>
            attribute unsigned short textDistance
          </dt>
          <dd>
            <p>
              The <a href="#edit_distance">edit distance</a> tolerance for the <a>text</a> attribute string. 
            </p>

            <p>The default value of the <a>textDistance</a> attribute MUST be <code>0</code>.</p>

            <p>If the value of the <a>text</a> attribute is the empty string, the <a>textDistance</a> attribute MUST use the default value.</p>
          </dd>

          <dt>
            attribute DOMString prefix
          </dt>
          <dd>
            <p>
              A text string of arbitrary length (often 32 characters) that precedes the target string.
            </p>

            <p>The default value of the <a>prefix</a> attribute MUST be the empty string.</p>

            <p class="issue">
              Include link to study that shows optimal distance for character prefixes?
            </p>
          </dd>

          <dt>
            attribute unsigned short prefixDistance
          </dt>
          <dd>
            <p>
              The <a href="#edit_distance">edit distance</a> tolerance for the <a>prefix</a> attribute string. 
            </p>

            <p>The default value of the <a>prefixDistance</a> attribute MUST be <code>0</code>.</p>

            <p>If the value of the <a>prefix</a> attribute is the empty string, the <a>prefixDistance</a> attribute MUST use the default value.</p>
          </dd>

          <dt>
            attribute DOMString suffix
          </dt>
          <dd>
            <p>
              A text string of arbitrary length (often 32 characters) that follows the target string.
            </p>

            <p>The default value of the <a>suffix</a> attribute MUST be the empty string.</p>

            <p class="issue">
              Include link to study that shows optimal distance for character suffixes?
            </p>
          </dd>

          <dt>
            attribute unsigned short suffixDistance
          </dt>
          <dd>
            <p>
              The <a href="#edit_distance">edit distance</a> tolerance for the <a>suffix</a> attribute string. 
            </p>

            <p>The default value of the <a>suffixDistance</a> attribute MUST be <code>0</code>.</p>

            <p>If the value of the <a>suffix</a> attribute is the empty string, the <a>suffixDistance</a> attribute MUST use the default value.</p>
          </dd>

          <dt>
            attribute Element scope
          </dt>
          <dd>
            <p>
              The DOM range which delineates the bounds of the search operation. The default range MUST be a range comprising the document's body element.
            </p>

            <p class="issue">
              This was originally a range, not an an element. I'm not sure why I did that, because ranges are a PITA to work with if you don't need to… surely there must be a reason I made it a range? Maybe because I wanted to give the developer the power to select non-element start and stop points?
            </p>
          </dd>

          <dt>
            attribute Range startRange
          </dt>
          <dd>
            <p>
              A range object, as the starting point for the selection search.

              <p class="issue">
                Do we really need both <code>cursor</code> and <code>startRange</code>? Working with an index would be easier than working with a range, and I'm not sure what having a range gets us.
              </p>
            </p>
          </dd>

          <dt>
            attribute caseFoldingType caseFolding
          </dt>
          <dd>
            <p>
              A boolean representing whether a search MUST ignore the case of the characters when doing match comparison. The default value MUST be <code>true</code>.
            </p>
          </dd>

          <dt>
            attribute UnicodeEquivalenceType unicodeNormalization
          </dt>
          <dd>
            <p> 
              A enumerated value representing whether a search MUST match exact characters, or use a particular Unicode character equivalence. The default value MUST be <code>none</code>.
            </p>
            <p> 
              Canonical Equivalence is described in [[!UTS10]]. If the value of this attribute is true, the User Agent MUST follow the algorthim defined in section <a href="http://unicode.org/reports/tr10/#Searching">8 Searching and Matching</a>, with collations and contractions formed per section <a href="http://unicode.org/reports/tr10/#Collation_Folding">8.1 Collation Folding</a>, and secondary strength asymmetric search per section <a href="http://unicode.org/reports/tr10/#Asymmetric_Search">8.2 Asymmetric Search</a>.
            </p>

            <p class="issue">
              We should require that the UA support the Character Model for the World Wide Web: String Matching and Searching [[!charmod-norm]] spec (and urge the I18n WG to complete that spec).
            </p>

            <p class="issue">
              This still needs a lot of work!
            </p>

            <p class="issue">
              Should we allow the author to supply their own tailoring mapping?
            </p>

            <p class="issue">
              This needs to be balanced with other kinds of fuzzy matches, such as case-folding and edit distance.
            </p>

          </dd>

          <dt>
            attribute boolean wholeWord
          </dt>
          <dd>
            <p>
              A boolean representing whether a search MUST require that the search string be surrounded by non-word characters. The default value MUST be <code>false</code>.
            </p>

            <p class="issue">
              Define how wholeWord interacts with edit distance. Probably wholeWord needs an exact match, regardless of edit distance tolerance.
            </p>

            <p class="issue">
              Define how wholeWord works in languages without word breaks. Probably any match there satisfies wholeWord (e.g. it doesn't matter how wholeWord is set).
            </p>
          </dd>

          <dt>
            attribute boolean wrap
          </dt>
          <dd>
            <p>
              A boolean representing whether a search MUST begin again at the beginning (or end, depending on search direction) of the <a>search tree</a>. The default value MUST be <code>false</code>.
            </p>
          </dd>

          <dt>
            attribute unsigned long cursor
          </dt>
          <dd>
            <p>
              An unsigned long indicating the current search index position in the <a>searchContent</a>. The default value MUST be <code>0</code>.
            </p>

            <p class="issue">
              I think this should be exposed, for extensibility and low-level access, but I'm open to arguments against it.
            </p>
          </dd>

          <dt>
            readonly attribute DOMString searchContent
          </dt>
          <dd>
            <p>
              The stringified and normalized content of the <a>search tree</a>.
            </p>

            <p class="issue">
              I think this should be exposed, for extensibility and low-level access, but I'm open to arguments against it. Note that this would be a really long string, in many cases!
            </p>
          </dd>

          <dt>
            readonly attribute DOMString sourceMap
          </dt>
          <dd>
            <p>
              The mapping between the <a>document</a> and the <a>searchContent</a>.
            </p>

            <p class="issue">
              I think this should be exposed, for extensibility and low-level access, but I'm open to arguments against it.
            </p>

            <p class="issue">
              I have no idea what this would actually look like! Probably JSON (which I don't know how to indicate in WebIDL), but otherwise completely undefined for now. :sadpanda:
            </p>
          </dd>
          
          <dt>
            Promise≺ResultMatch≻ search(optional boolean forward)
          </dt>
          <dd>
            <p>
              Executes the search, based on the current selection criteria attributes, from the current <a>search cursor</a> position within the document serialization. The return result MUST be a <code>Promise</code> of a <a>ResultMatch</a> object with properties defined as follows:
            </p>
            <ul>
              <li>
                If a match is found for the current selection criteria, the value of the <a>range</a> property MUST be a <code>Range</code> object that contains the target string or DOM structure.
              </li>
              
              <li>
                If no match is found for the current selection criteria, the value of the <code>range</code> property MUST be <code>null</code>.
              </li>
            </ul>
          
          <dt>
            Promise≺ResultMatchAll≻ searchAll(optional boolean forward)
          </dt>
          <dd>
            <p>
              Executes the search, based on the current selection criteria attributes, from the current <a>search cursor</a> position within the document serialization. The return result MUST be a <code>Promise</code> of a <a>ResultMatchAll</a> object with properties defined as follows:
            </p>
            <ul>
              <li>
                If a match is found for the current selection criteria, the value of the <a>range</a> property MUST be an array of <code>Range</code> objects that contains the target string or DOM structure.
              </li>
              
              <li>
                If no match is found for the current selection criteria, the value of the <code>range</code> property MUST be <code>null</code>.
              </li>
            </ul>

            <dl class="parameters">
              <dt>
                optional boolean forward
              </dt>
              <dd>
                <p>
                  This parameter indicates whether the search should proceed in forward (positive) direction from the current <a>search cursor</a>, or in a reverse (negative) direction. The default value MUST be <code>true</code>.
                </p>
                <p>
                  If the value is <code>true</code>, the search MUST continue in a positive direction along the character or DOM serialization, from the start of the document toward the end, beginning at the current <a>search cursor</a>.
                </p>
                <p>
                  If the value is <code>false</code>, the search MUST continue in a negative direction along the character or DOM serialization, from the end of the document toward the start, beginning at the current <a>search cursor</a>.
                </p>
              </dd>
            </dl>  

            <dl class="exceptions">
              <dt>
                DOMException error
              </dt>
              <dd>
                The error that occurred while searching.
              </dd>
            </dl>
          </dd>
        </dl>


        <dl title="enum caseFoldingType" class="idl">
          <dt>
            none
          </dt>
          <dd>
            The search MUST NOT use any case folding of characters.
          </dd>

          <dt>
            ascii
          </dt>
          <dd>
            The search MUST map all code points in the range 0x41 to 0x5A (A to Z) to the corresponding code points in the range 0x61 to 0x7A (a to z).

            <p class="issue">
              Should we defer to [[!charmod-norm]] for this definition?
            </p>
          </dd>
          
          <dt>
            unicode
          </dt>
          <dd>
            The search MUST map all code points to their Unicode C+F case fold equivalents. Note that this can change the length of the string.

            <p class="issue">
              Should we defer to [[!charmod-norm]] for this definition?
            </p>
          </dd>
          
          <dt>
            language-sensitive 
          </dt>
          <dd>
            The search MUST map all code points to their case-fold mappings defined in the Unicode Common Locale Data Repository [[!UAX35].

            <p class="issue">
              This is defined in [[!charmod-norm]], but should we defer value this to a later version of the spec?
            </p>
          </dd>
        </dl>

        <dl title="enum UnicodeEquivalenceType" class="idl">
          <dt>
            none
          </dt>
          <dd>
            The search MUST NOT use any Unicode equivalence of characters.
          </dd>

          <dt>
            canonical
          </dt>
          <dd>
            The search MUST use canonical (NFC/NFD) Unicode equivalence of characters.
          </dd>
          
          <dt>
            compatibility
          </dt>
          <dd>
            The search MUST use compatibility (NFKC/NFKD) Unicode equivalence of characters.

            <p class="issue">
              Does compatibility equivalence match digraph forms, as in the German <code>ö</code> to <code>oe</code>? If not, should we somehow include that anyway?
            </p>

            <p class="issue">
              Does compatibility equivalence match elided vowels, as in Hebrew? Or will we have to rely on edit distance? Note that there's only so far we can take this, with abbreviations demonstrating the extreme, such as matching <code>versus</code> and <code>vs</code> or <code>vs.</code>).
            </p>
          </dd>
          
          <dt>
            all
          </dt>
          <dd>
            The search MUST use either canonical (NFC/NFD) or compatibility (NFKC/NFKD) Unicode equivalence of characters, whichever produces the more liberal match.

            <p class="issue">
              Does compatibility already include canonical by definition?
            </p>

            <p class="issue">
              Performance issues?
            </p>
          </dd>
        </dl>


        <dl title='dictionary FindTextArgs' class='idl'>
          <dt>
            DOMString text
          </dt> <dd></dd>
          <dt>
            unsigned short textDistance
          </dt> <dd></dd>
          <dt>
            DOMString prefix
          </dt> <dd></dd>
          <dt>
            unsigned short prefixDistance
          </dt> <dd></dd>
          <dt>
            DOMString suffix
          </dt> <dd></dd>
          <dt>
            unsigned short suffixDistance
          </dt> <dd></dd>
          <dt>
            Range scope
          </dt> <dd></dd>
          <dt>
            Range startRange
          </dt> <dd></dd>
          <dt>
            caseFoldingType caseFolding
          </dt> <dd></dd>
          <dt>
            UnicodeEquivalenceType unicodeNormalization
          </dt> <dd></dd>
          <dt>
            boolean wholeWord
          </dt> <dd></dd>
          <dt>
            boolean wrap
          </dt>
        </dl>

        <dl title='dictionary ResultMatch' class='idl'>
          <dt>
            Range? result
          </dt>
          <dd>
            <p>
              A <a href="http://www.w3.org/TR/dom/#range">DOM Range object</a>, as defined in [[!DOM4]]. If no match is found, the value MUST be <code>null</code>.
            </p>
          </dd>

          <dt>
            dictionary FindTextArgs
          </dt>
          <dd>
            <p>
              A dictionary object which contains all the parameters used in the search.
            </p>

            <p>
              <a>FindTextArgs</a> MUST include entries for all available parameters, and MUST include default values for any parameter not explicitly set in the FindText object.
            </p>
          </dd>
        </dl>

        <dl title='dictionary ResultMatchAll' class='idl'>
          <dt>
            Array result
          </dt>
          <dd>
            <p>
              An array of <a href="http://www.w3.org/TR/dom/#range">DOM Range object</a>s, as defined in [[!DOM4]]. If no match is found, the array must be empty.
            </p>
          </dd>

          <dt>
            dictionary FindTextArgs
          </dt>
          <dd>
            <p>
              A dictionary object which contains all the parameters used in the search.
            </p>

            <p>
              <a>FindTextArgs</a> MUST include entries for all available parameters, and MUST include default values for any parameter not explicitly set in the FindText object.
            </p>
          </dd>
        </dl>

 <!-- 
        <section>
          <h3 id="lifetime-FindText" class="informative">
            Note goes here
          </h3>
          <p>
            Say anything useful.
          </p>
        </section>
 -->
      </section>
    </section>



    <section>
      <h2 id="api">
        The EditDistance Interface
      </h2>
      <p>The EditDistance API defines a method to calculate the minimum <a>edit distance</a> between any two strings. This method uses the Levenshtein Distance algorithm, with the following operations:</p>
      <ul>
        <li>Adding one character to the target string.</li>
        <li>Deleting one character from the target string.</li>
        <li>Replacing one character of the target string with another character.</li>
      </ul>
      <p>The EditDistance Interface is a lower-level API that acts as a helper API to the <a>FindText</a> API. It may also be used as a standalone method.</p>

      <p>Given two strings <var>s<sub>1</sub></var> and <var>s<sub>2</sub></var>, the edit distance between <var>s<sub>1</sub></var> and <var>s<sub>2</sub></var> is the minimum number of addition, deletion, and replacement operations required to convert string <var>s<sub>1</sub></var> to <var>s<sub>2</sub></var>.</p>

      <section>
        <h2>
          The EditDistance Method
        </h2>
        <dl title='interface EditDistance' class='idl'>
          <dt>unsigned short findEditDistance (in DOMString targetString, in DOMString comparisonString)</dt>
          <dd>
            <p>The findEditDistance method calculates the <a>edit distance</a> between the targetString and the comparisonString.</p>

            <dl class='parameters'>
              <dt>DOMString comparisonString</dt>
              <dd>
                Specifies the comparison string, which the target string is compared to. The default value MUST be the empty string.
              </dd>
              <dt>DOMString targetString</dt>
              <dd>
                Specifies the target string, which is compared to the comparison string. The default value MUST be the empty string.
              </dd>
            </dl>
          </dd>
        </dl>
      </section>
    </section>


    <section id="issues">
      <h2>
        Open Issues
      </h2>

      <p>
        These are open issues that don't yet have a location in the document.
      </p>

      <p class="issue">
        Explain how to tell when a search is complete, e.g. when all the matches have been found.
      </p>

      <p class="issue">
        How to deal with search matches that are dynamically inserted before the current <a>search cursor</a> position? LEave it up to the webapp?
      </p>

      <p class="issue">
        Should this find "meta" content, such as text in a <code>script</code>, <code>style</code>, <code>body</code>, or <code>CDATA</code> block?
      </p>

      <p class="issue">
        Should this find "hidden" content, such as text that is <code>display:none</code> or <code>visibility:none</code>?
      </p>

      <p class="issue">
        What are the minimum criteria for performing a search? You might usefully look for what's between the prefix and suffix, or what is at a certain range. Should we allow that, or require that the <code>text</code> attribute not be the empty string?
      </p>

      <p class="issue">
        Should we include an option to ignore punctuation? Apparently use of punctuation is widely variable and often changed, so this improves search efficiency.
      </p>

    </section>

    <section>
      <h2>
        Concepts
      </h2>
      <p>
        Algorithms defined in this specification assume that for each
        <a>document</a> there is a <dfn>pending promise</dfn>, which is
        initially set to <code>null</code>, which is a <a>Promise</a> object
        whose associated operation is to search the document.
      </p>
      <p>
        When <a title="queue a task">queuing a task</a>, the <dfn>find text task source</dfn> is used.
      </p>    
    </section>

    <section>
      <h3>Performing a search operation</h3>
      <p>A conforming <a>user agent</a> MUST perform a search operation in a manner that produces results consistent with this following algorithm. A conforming <a>user agent</a> MAY optimize the search algorithm in any way that produces these consistent results.</p>

      <div class='note'>
        <h4>Search Algorithm summary</h4>
        <p>
          The <code>FindText</code> <code>search()</code> method initiates an incremental text search of that portion 
          of the document set as the <code>scope</code> parameter of the <code>FindText</code> object, starting at its <code>startRange</code> parameter. 
        </p>
        <p>
          The search process starts by finding the scope of the search; given the <code>scope</code> range, it first finds the parent start and end elements, and all elements between them; these element comprise the <a>search tree</a>. It then extracts the text content of all these elements, and truncates everything outside the start and end character positions, using the algorithm defined for the <code>textContent</code> attribute in [[!DOM4]]; this is referred to as the <a>search content</a>.  
        </p>
        <p>
          In the <a>search content</a>, <code>target text</code>, and <code>prefix and suffix text</code>, all multiple consecutive whitespace characters, including newline characters, are collapsed into single space characters. If the <code>caseFolding</code> attribute is set to true, all characters are converted into their lowercase equivalents (if any). If the <code>unicodeNormalization</code> attribute is set to true, all characters are converted into their decomposed equivalents (if any), per the [[!charmod-norm]] spec. <i>If the <code>ignorePunctuation</code> attribute is set to true, all punctuation characters are removed.</i> (How should <code>wholeWord</code> be modeled?)
        </p>
        <p>
          Once the <a>search content</a>, <code>target text</code>, and  <code>prefix and suffix text</code> are normalized according to the required parameters, the search operation is begun. The starting point of the search is the character position of the <code>startRange</code> attribute; if this character position lies outside the scoped range, then the starting point of the search is the 0 position of the <a>search content</a> string.
        </p>
        <p>
          The <code>target text</code> is then incrementally compared with the <a>search content</a>, within the tolerance of the specified <a href="#edit_distance">edit distance</a>. Each such operation is performed at the current <a>search cursor</a>x character, starting with the first character and proceeding to each subsequent character. If there is a match, the prefix and suffix strings are also tested against the surrounding text and within their respective specified <a href="#edit_distance">edit distance</a> tolerances. If this also matches, then the process stops and the return results are prepared. If no appropriate match is found, the cursor character is incremented by a single character until a match is found, or until the end of the <a>search content</a> is reached if the <code>wrap</code> attribute is set to false. If the <code>wrap</code> attribute is set to true, and the start position was not the 0 position of the <a>search content</a> string, the search only concludes when the start position has been reached.
        </p>
        <p>
          The return results are prepared by first reconciling the matched string with its equivalent DOM range in the document. This range object is created, and bundled in an object with the original search parameters. This return object is in the form of a Promise, so the results can be analyzed and subsquent search operations can be performed by incrementing the start range position based on the matched range (if any). By performing this search multiple times, an application can incrementally find all matching ranges in the document.
        </p>
      </div>


      <h4>Search Algorithm</h4>
      <p>The steps to <dfn>perform a search operation</dfn> on a <a>document</a> using <a>FindText</a> are as follows:</p>

      <p class="issue">
        This algorithm is still a rough draft, and may change based on concrete feedback.
      </p>

      <ol id="search_algorithm">
        <li>If the <a>user agent</a> does not support searching the <a>document</a> using <a>FindText</a>,
          return a <a>Promise</a> rejected with a
          <code>DOMException</code> whose name is
          <code>NotSupportedError</code> and halt these steps.
        </li>
        <li>The following sub-steps MAY be run asynchronously for performance
        reasons, for example, if the <a>user agent</a> has <a title=
        'browsing context'>browsing contexts</a> living in different
        processes:
          <ol>
            <li>Let <var>browsing contexts</var> be the <a>list of the descendant browsing contexts</a> of the <a>top-level browsing context</a>'s <a>document</a>.</li>
            <li>For each <a data-link-type="dfn" class="internalDFN" href="#dfn-browsing-context">browsing context</a> in <var>browsing contexts</var>, run the following sub-steps:
              <ol>
                <li>Let <var>doc</var> be the <a data-link-type="dfn" class="internalDFN" href="#dfn-browsing-context">browsing context</a>'s <a data-link-type="dfn" class="internalDFN" href="#dfn-active-document">active document</a>.</li>
                <li>If <var>doc</var> is not visible per [<cite><a href="#bib-PAGE-VISIBILITY" class="bibref">PAGE-VISIBILITY</a></cite>], halt these steps.</li>


                <!-- prep promise -->
                <li>If <var>doc</var>'s <a>document</a>'s <a>pending promise</a> is not <code>null</code>:
                  <ol>
                    <li>Let <var>doc</var> be the <a>document</a> which has a not <code>null</code> <a>pending promise</a>.
                    </li>
                    <li>Reject <var>doc</var>'s <a>pending promise</a> with <code>DOMException</code> whose name is <code>EndError</code>.
                    </li>
                    <li>Set <var>doc</var>'s <a>pending promise</a> to <code>null</code>.</li>
                  </ol>
                </li>

                <!-- prep search content -->
                <li>Let <var>search tree</var> be the active target portion of <var>doc</var>.</li>
                <li>Set initial value of <var>search tree</var> to <var>doc</var>.</li>
                <li>If <a>scope</a> is not <code>null</code>:
                  <ol>
                    <li>If the value of <a>scope</a> is found within <var>doc</var>, set the value of <var>search tree</var> to the value of <a>scope</a>.</li>
                    <li>If the value of <a>scope</a> is not found within <var>doc</var>, resolve <var>doc</var>'s <a data-link-type="dfn" class="internalDFN" href="#dfn-pending-promise">pending promise</a> with <code>NOT FOUND</code>.
                      <p class="issue">
                        Define <code>NOT FOUND</code>, or find a better return value.
                      </p>
                    </li> 
                  </ol>
                  <p class="issue">
                    This conflates the notion of range and DOM tree. Find a better way to set the <var>search tree</var> to the <a>scope</a>.
                  </p>
                </li>
                <li>Let <var>search content</var> be the result of applying the <a href="http://www.w3.org/TR/dom/#dom-node-textcontent">[[!DOM4]] <code>textContent</code> attribute algorithm</a> algorithm to the <var>search tree</var>.
                  <p class="issue">
                    Note that this will not allow users to search for CSS-injected content, as currently defined. This is unintuitive, and may not match browser find-in-page behavior.
                  </p>
                </li>
                <li>Let <var>source map</var> be the mapping between each element boundary in <var>doc</var> and the corresponding character position in <var>search content</var>.</li>


                <!-- prep target text -->
                <li>Let <var>target text</var> be the discrete values of <a>text</a>, <a>prefix</a>, and <a>suffix</a>.</li>

                <!-- set internalization parameters -->
                <li>Collapse all consecutive sequences of any <a>whitespace character</a> into a single U+0020 (space) character, in the <var>search content</var> and <var>target text</var>.</li>
                <li>If <a>caseFolding</a> is not <code>null</code> or the value is not <code>none</code>:
                  <ol>
                    <li>If the value of <a>caseFolding</a> is <code>ascii</code>, map all code points in the range 0x41 to 0x5A (A to Z) to the corresponding code points in the range 0x61 to 0x7A (a to z), in the <var>search content</var> and <var>target text</var>.</li>
                    <li>If the value of <a>caseFolding</a> is <code>unicode</code>, map all code points to their Unicode C+F case fold equivalents, in the <var>search content</var> and <var>target text</var>.</li>
                  </ol>

                  <p class="issue">
                    Should we defer to [[!charmod-norm]] for this part of the algorithm?
                  </p>

                </li>
                <li>Update <var>source map</var> to reflect the new character positions in <var>search content</var>.</li>

                <li>If <a>unicodeNormalization</a> is not <code>null</code> or the value is not <code>none</code>:
                  <ol>
                    <li>If the value of <a>unicodeNormalization</a> is <code>canonical</code>, convert all characters in the <var>search content</var> and <var>target text</var> their Unicode equivalents using canonical (NFC/NFD) Unicode equivalence of characters.</li>
                    <li>If the value of <a>unicodeNormalization</a> is <code>compatibility</code>, convert all characters in the <var>search content</var> and <var>target text</var> their Unicode equivalents using compatibility (NFKC/NFKD) Unicode equivalence of characters.</li>
                    <li>If the value of <a>unicodeNormalization</a> is <code>all</code>, …
                      <p class="issue">
                        Is there a good way to handle this?
                      </p>
                    </li>
                  </ol>
                  <p class="issue">
                    Consider exposing unicode normalization operations as a separate method.
                  </p>
                </li>
                <li>Update <var>source map</var> to reflect the new character positions in <var>search content</var>.</li>

                <!-- set search cursor -->
                <li>Let <a>search cursor</a> be the current character position within <var>search content</var>.</li>
                <li>If this is the first initialization of the search execution:
                  <ol>
                    <li>Set <a>search cursor</a> to 0.</li>
                    <li>If <a>startRange</a> is not <code>null</code>:
                      <ol>
                        <li>If the starting point of <a>startRange</a> is found within <var>search content</var>, set the <a>search cursor</a> to the start of the start range.</li>
                      </ol>
                    </li>                    
                  </ol>
                  <p class="issue">
                    Find a clearer way to explain that the cursor position remains active between executions of the <code>search()</code> method, e.g. it's iterable. We don't want this to be idempotent.
                  </p>
                </li>
                <li>Let <a>search cursor starting position</a> be <a>search cursor</a>.</li>

                <!-- start search operation -->

                <li>Let <var>text match length</var> be the number of Unicode codepoints in <a>text</a>.</li>
                <li>Let <var>prefix match length</var> be the number of Unicode codepoints in <a>prefix</a>.</li>
                <li>Let <var>suffix match length</var> be the number of Unicode codepoints in <a>suffix</a>.</li>

                <li>Increment <a>search cursor</a> by 1 character until the <a>search cursor</a> is positioned on the last character in <var>search content</var>; for each increment:
                  <ol>
                    <li>If <a>wrap</a> is <code>true</code> and <a>search cursor</a> is <a>search cursor starting position</a>:
                      <ol>
                        <li>If execution method is <a>searchAll</a>, resolve <var>doc</var>'s <a data-link-type="dfn" class="internalDFN" href="#dfn-pending-promise">pending promise</a> with <var>result</var>.</li>
                      </ol>
                      <li>Halt this algorithm.</li>
                    </li>

                    <li>If execution method is <a>searchAll</a>:
                      <ol>
                        <li>Resolve <var>doc</var>'s <a data-link-type="dfn" class="internalDFN" href="#dfn-pending-promise">pending promise</a> with <var>result</var>.</li>
                        <li>Halt this algorithm.</li>
                      </ol>
                    </li>

                    <!-- text search operation -->
                    <li>Let <var>candidate text subset</var> be the string consisting of the number of Unicode codepoints in <a>search content</a> equal to <var>text match length</var> plus the value of <a>textDistance</a>, starting at the current <a>search cursor</a>.</li>
                    <li>Apply <var><a href="#text_match_algorithm">text match algorithm</a></var>:
                      <ol>
                        <li>Set <var>target text</var> to <a>text</a>.</li>
                        <li>Set <var>candidate text</var> to <a>candidate text subset</a>.</li>
                        <li>If <a>text</a> and <a>candidate text subset</a> are a match:
                          <ol>
                            <li>Let <var>matching candidate text</var> be <var>candidate text subset</var>.</li>
                            
                            <!-- prefix search operation -->
                            <li>Let <var>candidate text subset</var> be the string consisting of the number of Unicode codepoints in <a>search content</a> equal to <var>prefix match length</var> plus the value of <a>prefixDistance</a>, starting at the current <a>search cursor</a> minus the <var>prefix match length</var>.</li>
                            <li>Apply <var><a href="#text_match_algorithm">text match algorithm</a></var>:
                              <ol>
                                <li>Set <var>target text</var> to <a>prefix</a>.</li>
                                <li>Set <var>candidate text</var> to <a>candidate text subset</a>.</li>
                                <li>If <a>prefix</a> and <a>candidate text subset</a> are a match:
                                  <ol>

                                    <!-- suffix search operation -->
                                    <li>Let <var>candidate text subset</var> be the string consisting of the number of Unicode codepoints in <a>search content</a> equal to <var>suffix match length</var> plus the value of <a>prefixDistance</a>, starting at the current <a>search cursor</a> minus the <var>suffix match length</var>.</li>
                                    <li>Apply <var><a href="#text_match_algorithm">text match algorithm</a></var>:
                                      <ol>
                                        <li>Set <var>target text</var> to <a>suffix</a>.</li>
                                        <li>Set <var>candidate text</var> to <a>candidate text subset</a>.</li>
                                        <li>If <a>suffix</a> and <a>candidate text subset</a> are a match:
                                          
                                          <!-- match found, find range -->                                   
                                          <ol>
                                            <!-- <li>Let <var>result</var> be a <a>ResultMatch</a>.</li> -->
                                            <li>If execution method is <a>search</a>, let <var>result</var> be <a>DOM range object</a>.</li>
                                            <li>If execution method is <a>searchAll</a>, let <var>result</var> be an array of <a>DOM range object</a>s.</li>
                                            <li>Let <var>range</var> be a <a>DOM range object</a> in <var>result</var>.</li>
                                            <li>Set <var>range</var> to a <code>range</code> in <var>doc</var> corresponding to <var>matching candidate text</var>, using <var>source map</var>.
                                              <p class="issue">
                                                Probably needs more detail. :P
                                              </p>
                                            </li>
                                            <li>If execution method is <a>search</a>:
                                              <ol>
                                                <li>Resolve <var>doc</var>'s <a data-link-type="dfn" class="internalDFN" href="#dfn-pending-promise">pending promise</a> with <var>result</var>.
                                                  <p class="issue">
                                                    Should return cursor position also.
                                                  </p>
                                                </li>
                                                <li>Halt this algorithm.</li>
                                              </ol>
                                            </li>
                                          </ol>
                                          
                                        </li>
                                      </ol>
                                    </li>

                                  </ol>

                                </li>
                              </ol>
                            </li>

                          </ol>
                        </li>
                                          
                        <!-- no match found -->                                   
                        <li>Resolve <var>doc</var>'s <a data-link-type="dfn" class="internalDFN" href="#dfn-pending-promise">pending promise</a> with <code>MATCH NOT FOUND</code>.
                          <p class="issue">
                            Define <code>MATCH NOT FOUND</code>, or find a better return value.
                          </p>
                        </li> 
                        <li>If <a>wrap</a> is <code>true</code> and <a>search cursor starting position</a> is not <code>0</code>, set <a>search cursor</a> to <code>0</code>. Otherwise:
                          <ol>
                            <li>If execution method is <a>searchAll</a>, resolve <var>doc</var>'s <a data-link-type="dfn" class="internalDFN" href="#dfn-pending-promise">pending promise</a> with <var>result</var>.</li>
                            <li>Halt this algorithm.</li>                           
                          </ol>
                        </li>
                      </ol>
                    </li>
                 
                  </ol>
                </li>


            </li>
          </ol>
        </li>

      <li class="issue">
        Improve this algorithm!
      </li>

<!-- 

The target text is then incrementally compared with the search content, within the tolerance of the specified edit distance. Each such operation is performed at the current cursor character, starting with the first character and proceeding to each subsequent character. If there is a match, the prefix and suffix strings are also tested against the surrounding text and within their respective specified edit distance tolerances. If this also matches, then the process stops and the return results are prepared. If no appropriate match is found, the cursor character is incremented by a single character until a match is found, or until the end of the search content is reached if the wrap attribute is set to false. If the wrap attribute is set to true, and the start position was not the 0 position of the search content string, the search only concludes when the start position has been reached.

The return results are prepared by first reconciling the matched string with its equivalent DOM range in the document. This range object is created, and bundled in an object with the original search parameters. This return object is in the form of a Promise, so the results can be analyzed and subsquent search operations can be performed by incrementing the start range position based on the matched range (if any). By performing this search multiple times, an application can incrementally find all matching ranges in the document. 
 -->

      </ol>

      <h4>Text Match Algorithm</h4>
      <p>The steps to <dfn>perform a text match operation</dfn> on a <a>two strings</a> using <a>FindText</a> are as follows:</p>

      <ol id="text_match_algorithm">
        <li>Let <var>target text</var> be the string to match.</li>
        <li>Let <var>target text match length</var> be the number of Unicode codepoints in <a>target text</a>.</li>
        <li>Let <var>edit distance</var> be the character count variance.</li>
        <li>Let <var>candidate text</var> be the string to compare to <var>target text</var>.</li>
        <li>Let <var>match text</var> be the <code>empty string</code>.</li>
        <li>If <var>candidate text</var> and <a>text</a> contain an identical sequence of codepoints for the length of <var>target text match length</var>: 
          <ol>
            <li>Set <var>match text</var> to <var>candidate text</var>.</li>
            <li>Return <var>match text</var> and halt this algorithm.</li>
          </ol>
        </li>
        <li>If <a>wholeWord</a> is <code>true</code>, halt this algorithm.</li>
        <li>If <var>candidate text</var> and <a>text</a> match in a comparison using the <a>Calculating Edit Distance Algorithm</a>: 
          <ol>
            <li>Set <var>match text</var> to <var>candidate text</var>.</li>
            <li>Return <var>match text</var> and halt this algorithm.</li>
          </ol>
        </li>
      </ol>
    </section>

    <section>
      <h3>Calculating edit distance</h3>
      <p>A conforming <a>user agent</a> MUST calculate the edit distance of 2 strings in a manner that produces results consistent with this following algorithm. A conforming <a>user agent</a> MAY optimize the search algorithm in any way that produces these consistent results.</p>

      <div class='note'>
        <h4>Calculating Edit Distance Algorithm summary</h4>
        <p>The edit distance is calculated by first finding and comparing the matching sequence of codepoints in both strings, regardless of intervening extra characters. If the count of the mutual sequence of codepoint matches is within the user-defined tolerance limit (of <a>textDistance</a>, <a>prefixDistance</a>, and <a>suffixDistance</a>, respectively), then the string is considered a match using the change, insertion, or deletion operations.</p>

        <p>For example, the words <i>complete</i> and <i>computer</i> have the following mutual sequence of letters: <i>c</i>, <i>o</i>, <i>m</i>, <i>p</i>, <i>t</i>, and <i>e</i>. This pair has an edit distance of 3, because you must perform 3 operations: delete the <i>l</i>, change the <i>e</i> to an <i>u</i>, and add an <i>r</i>. So, a search for <i>complete</i> with an edit distance of 3 would also match <i>computer</i> (as well as more obvious matches like <i>completes</i>, <i>completed</i>, and <i>compete</i>).</p>

        <p>Note that in practice, all three of these operations can be combined, and are typically performed simultaneously.</p>      
      </div>

      <h4>Calculating Edit Distance Algorithm</h4>
      <ol id="edit_distance_algorithm">
        <li>
          
          <p class="issue">
            Define the EditDistance algorithm.
          </p>          
        </li>
      </ol>


    </section>

    <section id="examples" class="informative">
      <h2>Examples</h2>
      <p class="warning">
        This examples section is very much in flux, and the syntx may be wrong. The general ideas should be similar, but the syntax may be quite different. There may even be changes to the API based on feedback on the examples.
      </p>

      <p>
        Poetry, lyrics, and some prose often include significant repetition. A simple find-text operation would return only the first instance of a repetition, while the selection in question might be for the second or third instance.
      </p>


      <section id="example-1" class="informative">
        <h3>Example 1</h3>
        <p>
          In the following poem, there are four instances of the phrase “<i>Rage, rage</i>”; the desired selection is the third instance. Assuming an HTML page consisting only of the poem, there are several ways to use the FindText API to achieve this, a few of which are demonstrated below. Any or all of these techniques can be applied to ensure robust anchoring.
        </p>

        <article id="poem-1" class="example">
          <header>
            <b>Do Not Go Gentle Into That Good Night</b>
            <p>by Dylan Thomas</p>
          </header>
          <p>
            Do not go gentle into that good night,<br>
            Old age should burn and rave at close of day;<br>
            Rage, rage against the dying of the light.<br>
          </p>

          <p>
            Though wise men at their end know dark is right,<br>
            Because their words had forked no lightning they<br>
            Do not go gentle into that good night.
          </p>

          <p>
            Good men, the last wave by, crying how bright<br>
            Their frail deeds might have danced in a green bay,<br>
            Rage, rage against the dying of the light.
          </p>

          <p>
            Wild men who caught and sang the sun in flight,<br>
            And learn, too late, they grieved it on its way,<br>
            Do not go gentle into that good night.
          </p>

          <p>
            Grave men, near death, who see with blinding sight<br>
            Blind eyes could blaze like meteors and be gay,<br>
            <span class="highlight">Rage, rage</span> against the dying of the light.
          </p>

          <p>
            And you, my father, there on the sad height,<br>
            Curse, bless, me now with your fierce tears, I pray.<br>
            Do not go gentle into that good night.<br>
            Rage, rage against the dying of the light.    
          </p>
        </article>

        <div>
          <h4 id="ex1-m1">Method 1: Search and filter all results</h4>
          <pre class="example"><code>
var find = new FindText({ "text": "Rage, rage" });
find.searchAll().then( 
  function( ResultMatchAll ) {          // ResultMatchAll returns an array of all matching instances, as ranges
    var match = ResultMatch.result[2];  // target instance is is 3rd member of result array
  }
);
          </code></pre>        
        </div>


        <div>
          <h4 id="ex1-m2">Method 2: Iterative search</h4>
          <pre class="example"><code>
function handleMatch( result ) {

  find.search().then( handleMatch );
  // do things with match check if it does what i need
  findText( string, result.position, ... ).search().then( handleMatch );
}
var find = new FindText({ 
                          "text": "Rage, rage", // the selection
                          "cursor": 0 // the 32 characters preceding the selection 
                        });
var resultCount = 0;
handleMatch();
function handleMatch( result ) {
  if (3 > resultCount) {
    var match = find.search().then( handleMatch );
    if ( match.result) {
      resultCount++;
    }
  }
}
          </code></pre>
          <p class="issue">
            I know this iterator is wrong, but I don't grok promises well enough yet to fit it, and I need more sleep.
          </p>
        </div>


        <div>
          <h4 id="ex1-m3">Method 3: Context search with prefix</h4>
          <pre class="example"><code>
var find = new FindText({ 
                          "text": "Rage, rage", // the selection
                          "prefix": "blaze like meteors and be gay, " // the 32 characters preceding the selection 
                        });
var match = find.search().result; // result is 1st instance of string after prefix
          </code></pre>
        </div>


        <div>
          <h4 id="ex1-m4">Method 4: Character count</h4>
          <pre class="example"><code>
var start_range = document.createRange();
    start_range.setStart(document, 696); // the character count of the normalized searchContent preceding the selection
    start_range.setEnd(document, 11);    // the character count of the selection
var find = new FindText({ "startRange": start_range }); 
var match = find.search().result;            // result is the 11 characters starting at the position 696
          </code></pre>
          <p class="issue">
            I don't think the algorithm currently accounts for the "character count" behavior, but you should have a way to make a match based only on character count and offsets in the searchContent, without a target string, for increased robustness (using multiple fallback selection criteria) and flexibility. Ranges only do this in the document, and we might want finer control for searchContent. But I'm not sure if this is the right way to do it. When scope was a range, that might have been another way.
          </p>          
        </div>


        <div>
          <h4 id="ex1-m5">Method 5: Edit distance and scope selector</h4>
          <pre class="example"><code>
var scope = document.querySelector("p:nth-of-type(5)"); // the 5th paragraph (the one containing the selection)  
var find = new FindText({ 
                          "scope": scope,
                          "text": "Range, range", // the selection, misspelled
                          "editDistance": 2; // the edit distance between "Rage, rage" and "Range, range"
                        });
var result = find.search().result; // result is 1st instance of string within scope element
          </code></pre>          
        </div>


        <div>
          <h4 id="ex1-m6">Method 6: Element scope</h4>
          <p class="note">
            The main difference here between the <code>scope</code> attribute (used in <a href="#ex1-m5">Method 5</a>) and the <code>startRange</code> attribute is that <code>startRange</code> sets the starting point for the search, while <code>scope</code> limits the scope. In other words, running <code>search()</code> again on this example will find the next instance in the next paragraph, while in the previous example, it will only find the single instance in the target paragraph.
          </p>
          <pre class="example"><code>
var start = document.querySelector("p:nth-of-type(5)"); // the 5th paragraph (the one containing the selection)  
var start_range = document.createRange();
    start_range.setStart(scope, 0);
    start_range.setEnd(scope, 1);    // the character count of the selection
var find = new FindText({ 
                          "startRange": start_range,
                          "text": "Rage, rage"
                        });
var result = find.search().result; // result is 1st instance of string, starting at location query selector
          </code></pre>
          <p class="issue">
            Actually, this might not work, because the range is on the document, while it's being applied to the normalized searchContent. Maybe there should be an intervening step.
          </p>
        </div>

      </section>
    </section>
   
    <section class='notes'>
      <h2>Notes</h2>
      <aside class="issue">
        <p>
          This API might be alternately designed as a Text interface, with various methods including search.
        </p>
        <pre><code>
Text interface
    unsigned short Text.findEditDistance (DOMString comparisonString, DOMString targetString);
    DOMString Text.collapseWhitespace();
    DOMString Text.stringify( Element );
    DOMString Text.foldUnicode( DOMString text, UnicodeEquivalenceType);
    Promise≺ResultMatch≻ Text.search (
                                    attribute DOMString              searchContent;
                                    attribute DOMString              text;
                                    attribute unsigned short         textDistance;
                                    attribute DOMString              prefix;
                                    attribute unsigned short         prefixDistance;
                                    attribute DOMString              suffix;
                                    attribute unsigned short         suffixDistance;
                                    attribute Range                  scope;
                                    attribute Range                  startRange;
                                    attribute caseFoldingType        caseFolding;
                                    attribute UnicodeEquivalenceType unicodeNormalization;
                                    attribute boolean                wholeWord;
                                    attribute boolean                wrap;
                                    optional boolean forward
                                   );
    DOMRange Text.findEquivalentRange( ... );

        </code></pre>  
      </aside>
    </section>

    <section class='appendix'>
      <h2>Acknowledgements</h2>
      <p>
        Special thanks to Cameron McCormack (Mozilla); Kristof Csillag (Hypothes.is); Randall Leeds (Hypothes.is); Dan Whaley (Hypothes.is); Mitar Milutinovic (UC-Berkeley); Jake Hartnell (UC-Berkeley, EPUB.js); Nick Stenning (Hypothes.is); Benjamin Young (Hypothes.is); Mike de Boer (Mozilla); Travis Leithead (Microsoft); Ryosuke Niwa (Apple); Josh Soref (Blackberry); Rob Sanderson (Stanford); Paolo Ciccarese (Mass General Hospital / Harvard); Takeshi Kanai (Sony); Ivan Herman (W3C); Robin Berjon (W3C); Mike™ Smith (W3C); Addison Phillips (Amazon), Richard Ishida (W3C), and the rest of the I18n WG for internationalization insight; Alex Schmidtz (jQuery), Bill Hunt (OpenGov Foundation), and Chris Birk (OpenGov Foundation) for expertise on Promises; Mounir Lamouri (Google) and Marcos Cáceres (Mozilla) for writing a spec I could plunder mechanics; Peter Brantley (for putting on the Books in Browsers conference); and the entire Web Annotation Working Group and Open Annotations Community Group for discussion and insight. If I've forgotten anyone, please remind me; I'm truly grateful for all the discussions I've had on this topic.
      </p>
    </section>
    
    <section id='tof'></section>

  </body>
</html>
